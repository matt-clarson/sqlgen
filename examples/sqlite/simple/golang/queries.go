// File generated by sqlgen. Do not edit.

package queries

import (
	"context"
	"database/sql"
)

type scannableRow interface {
	scanRow(*sql.Rows) error
}

type resultSet[TResult scannableRow] struct {
	rows   *sql.Rows
	create func() TResult
}

func (r *resultSet[TResult]) toSlice() ([]TResult, error) {
	var results []TResult
	for r.rows.Next() {
		result := r.create()
		if err := result.scanRow(r.rows); err != nil {
			return nil, err
		}
		results = append(results, result)
	}

	if err := r.rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}

type GetJoinedResult struct {
	T1Id       int32
	ColA       sql.NullString
	ColB       string
	T2Id       int32
	SomeValue  sql.NullFloat64
	OtherValue []byte
}

func createGetJoinedResult() GetJoinedResult {
	return GetJoinedResult{}
}

func (r GetJoinedResult) scanRow(rows *sql.Rows) error {
	return rows.Scan(
		&r.T1Id,
		&r.ColA,
		&r.ColB,
		&r.T2Id,
		&r.SomeValue,
		&r.OtherValue,
	)
}

func GetJoined(db *sql.DB, ctx context.Context) ([]GetJoinedResult, error) {
	query := `
        SELECT 
            t1.id t1_id,
            col_a,
            col_b,
            t2.id t2_id,
            some_value,
            other_value
        FROM
            table_1 t1
            JOIN table_2 t2 ON
                t1.id=t2.ref_1
            JOIN table_3 t3 ON
                t1.id=t3.ref_1
        ORDER BY t1.id
        LIMIT 10;
    `

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}

	results := resultSet[GetJoinedResult]{rows, createGetJoinedResult}

	return results.toSlice()
}

type GetTable1Result struct {
	Id   int32
	ColA sql.NullString
	ColB string
}

func createGetTable1Result() GetTable1Result {
	return GetTable1Result{}
}

func (r GetTable1Result) scanRow(rows *sql.Rows) error {
	return rows.Scan(
		&r.Id,
		&r.ColA,
		&r.ColB,
	)
}

func GetTable1(db *sql.DB, ctx context.Context) ([]GetTable1Result, error) {
	query := `
        SELECT * FROM table_1;
    `

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}

	results := resultSet[GetTable1Result]{rows, createGetTable1Result}

	return results.toSlice()
}

type InsertTable1Arg struct {
	Id   int32
	ColA string
	ColB string
}

func InsertTable1(db *sql.DB, ctx context.Context, arg InsertTable1Arg) error {
	query := `
        INSERT INTO table_1
        VALUES (
            ?,
            ?,
            ?
        );
    `

	_, err := db.ExecContext(ctx, query,
		arg.Id,
		arg.ColA,
		arg.ColB,
	)

	return err
}

type QueryJoinedArg struct {
	Msg string
	Val float64
}

type QueryJoinedResult struct {
	T1Id      int32
	ColA      sql.NullString
	SomeValue sql.NullFloat64
}

func createQueryJoinedResult() QueryJoinedResult {
	return QueryJoinedResult{}
}

func (r QueryJoinedResult) scanRow(rows *sql.Rows) error {
	return rows.Scan(
		&r.T1Id,
		&r.ColA,
		&r.SomeValue,
	)
}

func QueryJoined(db *sql.DB, ctx context.Context, arg QueryJoinedArg) ([]QueryJoinedResult, error) {
	query := `
        SELECT
            t1.id t1_id,
            col_a,
            some_value
        FROM
            table_1 t1
            JOIN table_2 t2
                ON t1.id=t2.ref_1
        WHERE
            col_b = ? AND
            some_value > ?;
    `

	rows, err := db.QueryContext(ctx, query,
		arg.Msg,
		arg.Val,
	)
	if err != nil {
		return nil, err
	}

	results := resultSet[QueryJoinedResult]{rows, createQueryJoinedResult}

	return results.toSlice()
}

